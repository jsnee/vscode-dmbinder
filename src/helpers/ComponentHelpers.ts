import { exec } from "child_process";
import { QuickPickItem, Uri, QuickPickOptions, window, TextDocument, ProgressOptions, ProgressLocation, Range } from "vscode";
import * as matter from 'gray-matter';
import * as fse from 'fs-extra';
import { ITreeItem } from "../models/ITreeItem";
import { campaignExplorerProvider } from "../campaignExplorerProvider";
import * as path from 'path';
import * as nhp from "node-html-parser";

export namespace ComponentHelpers {
    export async function buildComponent(templatePath: string, metadataPath: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            exec(`echo '' | pandoc --template="${templatePath}" --metadata-file="${metadataPath}" --metadata pagetitle=" "`, (error, stdout, stderr) => {
                resolve(stderr || stdout);
            });
        });
    }

    export async function promptGenerateComponent(item?: ITreeItem): Promise<string | undefined> {
        let componentUri: Uri | undefined;
        if (!item || !item.getTreeItem) {
            const qpComponentList = await campaignExplorerProvider.getComponentItems();
            if (qpComponentList) {
                const qpComponentOpts: QuickPickOptions = {
                    canPickMany: false,
                    ignoreFocusOut: true,
                    placeHolder: 'Select the component to use'
                };
                let componentItem = await window.showQuickPick(qpComponentList, qpComponentOpts);
                if (componentItem && componentItem.detail) {
                    componentUri = Uri.file(componentItem.detail);
                }
            }
        } else {
            const treeItem = await item.getTreeItem();
            componentUri = treeItem.resourceUri;
        }
        if (componentUri) {
            let templateUri = await getOrPromptTemplateUri(componentUri);
            if (templateUri) {
                return await buildComponent(templateUri.fsPath, componentUri.fsPath);
            }
        }
        return;
    }

    async function getOrPromptTemplateUri(componentUri: Uri): Promise<Uri | undefined> {
        const qpItemList = await campaignExplorerProvider.getTemplateItems();
        if (qpItemList) {
            let templateItem: QuickPickItem | undefined;
            if (componentUri.fsPath.endsWith(".yaml")) {
                let metadata = matter.read(componentUri.fsPath, { delimiters: ['---', '...'] });
                if (metadata && metadata.data && metadata.data.templateItem) {
                    templateItem = qpItemList.find((each) => each.label === `${metadata.data.templateItem}`);
                }
            } else if (componentUri.fsPath.endsWith(".json")) {
                let metadata = await fse.readJSON(componentUri.fsPath);
                if (metadata && metadata.templateItem) {
                    templateItem = qpItemList.find((each) => each.label === `${metadata.templateItem}`);
                }
            }
            if (!templateItem) {
                const qpOpts: QuickPickOptions = {
                    canPickMany: false,
                    ignoreFocusOut: true,
                    placeHolder: 'Select the template to use'
                };
                templateItem = await window.showQuickPick(qpItemList, qpOpts);
            }
            if (templateItem && templateItem.detail) {
                return Uri.file(templateItem.detail);
            }
        }
        return;
    }

    export async function autogenerateDocumentComponents(data: string, fileName: string): Promise<string> {
        const root = nhp.parse(`<dmb-autogenerator>${data}</dmb-autogenerator>`);
        if (root instanceof nhp.HTMLElement) {
            const targets = root.querySelectorAll(".dmb-autogen");
            if (targets.length < 1) {
                return data;
            }

            const componentList = await campaignExplorerProvider.getComponentItems();
            if (!componentList) {
                window.showWarningMessage("Failed to find any components in the current campaign.");
                return data;
            }

            for (let ndx = 0; ndx < targets.length; ndx++) {
                let node = targets[ndx] as nhp.HTMLElement;
                const matchedComponent = componentList.find(each => each.label === node.id);
                if (!matchedComponent || !matchedComponent.detail) {
                    window.showWarningMessage(`Failed to find a component named "${node.id}".`);
                    continue;
                }
                const componentUri = Uri.file(matchedComponent.detail);
                const templateUri = await getOrPromptTemplateUri(componentUri);
                if (!templateUri) {
                    window.showWarningMessage(`Failed to find a template for component "${node.id}".`);
                    continue;
                }
                const buildResult = await buildComponent(templateUri.fsPath, componentUri.fsPath);
                const child = new nhp.TextNode("\n\n" + buildResult);
                node.childNodes = [child];
            }
            let rootNode = root.firstChild as nhp.HTMLElement;
            return rootNode.innerHTML;
            
        } else {
            window.showWarningMessage("Failed to parse current document for component autogeneration elements.");
        }
        return data;
    }

    export async function autogenerateOpenDocumentComponents(doc: TextDocument): Promise<void> {
        const root = nhp.parse(`<dmb-autogenerator>${doc.getText()}</dmb-autogenerator>`);
        if (root instanceof nhp.HTMLElement) {
            const targets = root.querySelectorAll(".dmb-autogen");
            if (targets.length < 1) {
                return;
            }
            const fileName = path.basename(doc.fileName, '.md');
            const progOpts: ProgressOptions = {
                location: ProgressLocation.Notification,
                cancellable: true,
                title: `Autogenerating Components: ${fileName}`
            };

            window.withProgress(progOpts, async (progress, token) => {
                let isCancelled = false;
                token.onCancellationRequested(async () => {
                    window.showWarningMessage(`Cancelled rendering files from "${fileName}".`);
                    window.setStatusBarMessage("Cancelling...", 1000);
                });
                progress.report({
                    message: "Initializing..."
                });

                const componentList = await campaignExplorerProvider.getComponentItems();
                if (!componentList) {
                    window.showWarningMessage("Failed to find any components in the current campaign.");
                    return;
                }

                for (let ndx = 0; ndx < targets.length; ndx++) {
                    if (isCancelled) {
                        console.log("Cancelled!");
                        break;
                    }
                    let node = targets[ndx] as nhp.HTMLElement;
                    progress.report({
                        message: `Generating "${node.id}"...`,
                        increment: 100 / targets.length
                    });
                    const matchedComponent = componentList.find(each => each.label === node.id);
                    if (!matchedComponent || !matchedComponent.detail) {
                        window.showWarningMessage(`Failed to find a component named "${node.id}".`);
                        continue;
                    }
                    const componentUri = Uri.file(matchedComponent.detail);
                    const templateUri = await getOrPromptTemplateUri(componentUri);
                    if (!templateUri) {
                        window.showWarningMessage(`Failed to find a template for component "${node.id}".`);
                        continue;
                    }
                    const buildResult = await buildComponent(templateUri.fsPath, componentUri.fsPath);
                    const child = new nhp.TextNode("\n\n" + buildResult);
                    node.childNodes = [child];
                }

                progress.report({
                    message: `Updating "${fileName}" Contents...`
                });
                const editor = await window.showTextDocument(doc);
                let range = new Range(0, 0, doc.lineCount, 0);
                range = doc.validateRange(range);
                let rootNode = root.firstChild as nhp.HTMLElement;
                await editor.edit((editBuilder) => {
                    editBuilder.replace(range, rootNode.innerHTML);
                });
            });
            
        } else {
            window.showWarningMessage("Failed to parse current document for component autogeneration elements.");
        }
    }
}